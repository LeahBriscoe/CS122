import sys
import logging
import numpy as np
from collections import defaultdict
import time
from os.path import join
from basic_hasher import build_hash_and_pickle, hashing_algorithm
import zipfile

# from helpers.helpers import *

READ_LENGTH = 50


##### COPY COPY COPY
def read_reads(read_fn):
    f = open(read_fn, 'r')
    first_line = True
    all_reads = []
    for line in f:
        if first_line:
            first_line = False
            continue  # We skip the first line, since it
            # only contains the name of the chromosome the reads
            # came from.
        line = line.strip()
        paired_end_reads = line.split(',')  # The two paired ends are separated by a comma
        all_reads.append(paired_end_reads)
    return all_reads


def read_reference(ref_fn):
    f = open(ref_fn, 'r')
    first_line = True
    output_reference = ''
    for line in f:
        if first_line:
            first_line = False
            continue  # We skip the first line, since it
            # only contains the name of the chromosome the reads
            # came from.
        line = line.strip()
        output_reference += line  # We append each line to the output reference string.
    return output_reference


def pretty_print_aligned_reads_with_ref(genome_oriented_reads, read_alignments, ref, read_length=50,
                                        line_length=100, read_sep=100, buffer=30):
    """
    :param genome_oriented_reads: oriented reads generated by an alignment algorithm
    :param read_alignments: alignments generated from an alignment algorithm
    :param ref: reference generated by read_ref
    :return: Returns nothing, but prints the reads aligned to the genome to
     show you what pileup actually *LOOKS* like. You should be able to call SNPs
     by eyeballing the output. However, there are some reads that will not align.
     In the future you'll want to re-check why these reads aren't aligning--the cause
     is usually a structural variation, like an insertion or deletion.
    """
    output_str = ''
    good_alignments = [read_sep + read_length - buffer < x[1] - x[0] <
                       read_sep + read_length + buffer for x in read_alignments]
    # There should be read_length + x (90 < x < 110) p between the reads, and we give a little
    # extra space in case there's been a deletion or insertion.  Depending on the type of
    # deletions/insertions

    best_reads = [genome_oriented_reads[i] for i in range(len(good_alignments))
                  if good_alignments[i]]
    # Remove the reads that do not have a good alignment, or a good reverse alignment.
    best_alignments = [read_alignments[i] for i in range(len(read_alignments))
                       if good_alignments[i]]
    # Take their corresponding alignments
    aligned_reads = [best_reads[i][0] + '.' * (best_alignments[i][1] - best_alignments[i][0] - read_length)
                     + best_reads[i][1] for i in range(len(best_reads))]
    # This turns the reads into strings oriented towards the genome.
    # We get the first read, followed by the correct number of dots to join the first and second reads,
    # and then the second read.

    first_alignment = [x[0] for x in best_alignments]
    alignment_indices = np.argsort(first_alignment)
    sorted_reads = [aligned_reads[i] for i in alignment_indices]
    sorted_alignments = [best_alignments[i] for i in alignment_indices]

    # You don't need to worry too much about how the code block below works--its job is to make it so
    # that a read that starts printing in the third row will continue printing in the third row of the
    # next set of lines.
    active_reads = []
    output_str += '\n\n' + '-' * (line_length + 6) + '\n\n'
    for i in range(len(ref) / line_length):
        next_ref = ref[i * line_length: (i + 1) * line_length]
        new_read_indices = [j for j in range(len(sorted_reads))
                            if i * line_length <= sorted_alignments[j][0] < (i + 1) * line_length]
        space_amounts = [sorted_alignments[index][0] % line_length for index in new_read_indices]
        new_reads = [sorted_reads[index] for index in new_read_indices]
        new_reads_with_spaces = [' ' * space_amounts[j] + new_reads[j] for j in range(len(new_reads))]
        empty_active_read_indices = [index for index in range(len(active_reads)) if active_reads[index] == '']
        for j in range(min(len(new_reads_with_spaces), len(empty_active_read_indices))):
            active_reads[empty_active_read_indices[j]] = new_reads_with_spaces[j]

        if len(new_reads_with_spaces) > len(empty_active_read_indices):
            active_reads += new_reads_with_spaces[len(empty_active_read_indices):]
        printed_reads = ['Read: ' + read[:line_length] for read in active_reads]
        active_reads = [read[line_length:] for read in active_reads]
        while len(active_reads) > 0:
            last_thing = active_reads.pop()
            if last_thing != '':
                active_reads.append(last_thing)
                break
        output_lines = ['Ref:  ' + next_ref] + printed_reads
        output_str += 'Reference index: ' + str(i * line_length) + \
                      '\n' + '\n'.join(output_lines) + '\n\n' + '-' * (line_length + 6) + '\n\n'
    # print output_str
    return output_str


###### COPY COPY COPY


def generate_pileup(aligned_fn):
    logging.warn("generate_pileup")
    """
    :param aligned_fn: The filename of the saved output of the basic aligner
    :return: SNPs (the called SNPs for uploading to the herokuapp server)
             output_lines (the reference, reads, consensus string, and diff string to be printed)
    """
    line_count = 0
    lines_to_process = []
    changes = []
    reference_strand = ''
    donor_strand = ''
    with open(aligned_fn, 'r') as input_file:
        for line in input_file:
            line_count += 1
            line = line.strip()
            if line_count <= 4 or line == '':  # The first 4 lines need to be skipped
                continue
            if len(line) > 0 and all(x == '-' for x in line):  # The different pieces of the genome are set off
                # with lines of all dashes '--------'
                new_changes, refe, donore = process_lines(lines_to_process)
                reference_strand += refe
                donor_strand += donore
                lines_to_process = []
                changes += new_changes
                # print time.clock() - start, 'seconds'
            else:
                lines_to_process.append(line)
    snps = [v for v in changes if v[0] == 'SNP']

    insertions = [v for v in changes if v[0] == 'INS']
    deletions = [v for v in changes if v[0] == 'DEL']

    # print "ref   " + str(reference_strand)
    # print "donor " + str(donor_strand)

    new_snps = []
    inversion_potential = []

    i = 1
    while i < len(snps)-1:
        # print snps[i]
        if abs(snps[i - 1][3] - snps[i][3]) > 8 and abs(snps[i + 1][3] - snps[i][3]) > 8:
            # print "pass"

            if i == 1:
                new_snps.append(snps[0])
                new_snps.append(snps[i])
            elif i == len(snps) - 2:
                new_snps.append(snps[i])
                new_snps.append(snps[len(snps)-1])
            else:
                new_snps.append(snps[i])
            i += 1

        else:
        # if abs(snps[i - 1][3] - snps[i][3]) < 15 or abs(snps[i + 1][3] - snps[i][3]) < 15:
            # print snps[i][1]
            # print snps[i][2]
            # print snps[i][3]
            inversion_potential.append(snps[i][3])
            i += 1

    snps = new_snps

    #########
    # print "inversion Potential"
    # print inversion_potential
    inversion_range_pair = []
    open_frame = True
    for i in range(0,len(inversion_potential)-1):
        if inversion_potential[i] > inversion_potential[i+1]-10 and open_frame:
            first_one = inversion_potential[i]
            open_frame = False
        if inversion_potential[i] < inversion_potential[i+1]-10:
            inversion_range_pair.append((first_one,inversion_potential[i]))
            open_frame = True
        # if inversion_potential
    # print "Inversion Pairs"
    # print inversion_range_pair

    # print "filtered pairs"
    filtered_pairs = []
    for one,two in inversion_range_pair:
        if two - one > 9:
            filtered_pairs.append((one,two))

    # print filtered_pairs

    actual_inversions = []
    key_length = 8

    for one,two in filtered_pairs:
        # print one
        i = one
        j = two + 1
        # print reference_strand[i:j]
        # print donor_strand[i:j]

        # if first range is not a match
        if reference_strand[i:j] != donor_strand[i:j][::-1]:

            genome_hash = defaultdict(list)
            for k in range(i, j+1):
                ref_piece = reference_strand[k:k + key_length]
                genome_hash[ref_piece].append(k)
            # print "test"
            # print genome_hash.keys()
            for k in range(one, two+1):
                #for value in genome_hash[donor_strand[k:k + key_length][::-1]]
                if genome_hash[donor_strand[k:k + key_length][::-1]]:

                    # print genome_hash[donor_strand[k:k + key_length][::-1]][0]
                    i = k
                    j = genome_hash[donor_strand[k:k + key_length][::-1]][0] + key_length
                    # print "Index found"
                    # print donor_strand[i:j]
                    break
            '''
            not_done = True
            while not_done and j-i > 15 and j-i < 201:
                if reference_strand[i-1:j] == donor_strand[i-1:j][::-1]:
                    i -= 1
                    print "more left inversion"
                else:
                    not_done = False
            '''


        if reference_strand[i:j] == donor_strand[i:j][::-1]:
            # print "Inversion"
            not_done = True
            while not_done:

                if reference_strand[i-1:j+1] == donor_strand[i-1:j+1][::-1]:
                    i -= 1
                    j += 1
                    # print "more outward inversion"
                else:
                    not_done = False

            actual_inversions.append([reference_strand[i:j], i])

    # changes.append(['SNP', ref[current_row], donor[current_column], ref_index])
    #print "actual inversions"
    # print actual_inversions
    ###########
    inversions = actual_inversions
    print "Inversions LENGTH " + str(len(inversions))

    print "SNPS LENGTH " + str(len(snps))
    print "Insertions LENGTH " + str(len(insertions))
    print "Deletions LENGTH " + str(len(deletions))
    return snps, insertions, deletions, inversions


def process_lines(genome_lines):
    """
    :param genome_lines: Lines in between dashes from the saved output of the basic_aligner
    :return: snps (the snps from this set of lines)
             output_lines (the lines to print, given this set of lines)
    """
    line_count = 0
    consensus_lines = []
    for line in genome_lines:
        line_count += 1
        if line_count == 1:  # The first line contains the position in the reference where the reads start.
            raw_index = line.split(':')[1]  # picks the index in the line "Reference: 100" or the DNA string
            line_index = int(raw_index)
        else:
            consensus_lines.append(line[6:])
    ref = consensus_lines[0]
    aligned_reads = consensus_lines[1:]
    donor = generate_donor(ref, aligned_reads)
    # print "ref " + str(ref)
    # print "don " + str(donor)

    if ref == donor:
        # print "all good"
        return [], ref, donor

    use_this_index = 0
    i = 0
    while i < len(ref):
        if ref[i] == donor[i]:
            i += 1
        else:
            use_this_index = i
            break
    # print "index of change" + str(use_this_index)

    changes = identify_changes(ref[use_this_index:], donor[use_this_index:], use_this_index + line_index)
    return changes, ref, donor


def align_to_donor(donor, read):
    """
    :param donor: Donor genome (a character string of A's, T's, C's, and G's, and spaces to represent unknown bases).
    :param read: A single read padded with spaces
    :return: The best scoring
    """

    mismatches = [1 if donor[i] != ' ' and read[i] != ' ' and
                       read[i] != donor[i] else 0 for i in range(len(donor))]
    n_mismatches = sum(mismatches)
    overlaps = [1 if donor[i] != ' ' and read[i] != ' ' else 0 for i in range(len(donor))]
    n_overlaps = sum(overlaps)
    score = n_overlaps - n_mismatches
    if n_mismatches <= 2:
        return read, score
    else:
        # print "bad matching"
        # print donor
        # print read
        # print "score" + str(score)
        best_read = read
        best_score = score

    for shift_amount in range(-2, 0) + range(1, 3):  # This can be improved
        if shift_amount > 0:
            shifted_read = ' ' * shift_amount + read
        elif shift_amount < 0:
            shifted_read = read[-shift_amount:] + ' ' * (-shift_amount)
        mismatches = [1 if donor[i] != ' ' and shifted_read[i] != ' ' and
                           shifted_read[i] != donor[i] else 0 for i in range(len(donor))]
        n_mismatches = sum(mismatches)
        overlaps = [1 if donor[i] != ' ' and shifted_read[i] != ' ' else 0 for i in range(len(donor))]
        n_overlaps = sum(overlaps)
        score = n_overlaps - n_mismatches - 3 * abs(shift_amount)
        if score > best_score:
            best_read = shifted_read
            best_score = score

    # print best_read, best_score
    return best_read, best_score


def generate_donor(ref, aligned_reads):
    """
    Aligns the reads against *each other* to generate a hypothesized donor genome.
    There are lots of opportunities to improve this function.
    :param aligned_reads: reads aligned to the genome (with pre-pended spaces to offset correctly)
    :return: hypothesized donor genome
    """
    cleaned_aligned_reads = [_.replace('.', ' ') for _ in aligned_reads]
    ## Start by appending spaces to the reads so they line up with the reference correctly.
    padded_reads = [aligned_read + ' ' * (len(ref) - len(aligned_read)) for aligned_read in cleaned_aligned_reads]
    consensus_string = consensus(ref, aligned_reads)

    ## Seed the donor by choosing the read that best aligns to the reference.
    # For each portion of the genome, choosing the read that matches best
    read_scores = [sum([1 if padded_read[i] == ref[i] and padded_read[i] != ' '
                        else 0 for i in range(len(padded_read))])
                   for padded_read in padded_reads]
    # print "Length of padded reads " + str(len(padded_reads))
    # print padded_reads
    if not read_scores:
        return consensus_string
    longest_read = padded_reads[read_scores.index(max(read_scores))] # chose read with highest score
    donor_genome = longest_read
    # While there are reads that haven't been aligned, try to align them to the donor.

    '''
    while padded_reads:
        un_donored_reads = []
        for padded_read in padded_reads:
            re_aligned_read, score = align_to_donor(donor_genome, padded_read)
            # print "score" + str(score)
            if score < 0.90 * len(padded_read.strip()):  # If the alignment isn't good, throw the read back in the set of reads to be aligned.
                un_donored_reads.append(padded_read)
            else:
                donor_genome = ''.join([re_aligned_read[i] if donor_genome[i] == ' ' else donor_genome[i]
                                        for i in range(len(donor_genome))])

        if len(un_donored_reads) == len(padded_reads):
            # If we can't find good alignments for the remaining reads, quit
            break
        else:
            # Otherwise, restart the alignment with a smaller set of unaligned reads
            padded_reads = un_donored_reads
    '''
    # Fill in any gaps with the consensus sequence and return the donor genome.
    donor_genome = ''.join([donor_genome[i] if donor_genome[i] != ' ' else consensus_string[i] for i
                            in range(len(donor_genome))])


    # print donor_genome
    return donor_genome


def edit_distance_matrix(ref, donor):
    """
    Computes the edit distance matrix between the donor and reference
    This algorithm makes substitutions, insertions, and deletions all equal.
    Does that strike you as making biological sense? You might try changing the cost of
    deletions and insertions vs snps.
    :param ref: reference genome (as an ACTG string)
    :param donor: donor genome guess (as an ACTG string)
    :return: complete (len(ref) + 1) x (len(donor) + 1) matrix computing all changes
    """

    output_matrix = np.zeros((len(ref), len(donor)))
    # print len(ref), len(donor)
    # print output_matrix
    # This is a very fast and memory-efficient way to allocate a matrix
    for i in range(len(ref)):
        output_matrix[i, 0] = i
    for j in range(len(donor)):
        output_matrix[0, j] = j
    for j in range(1, len(donor)):
        for i in range(1, len(ref)):  # Big opportunities for improvement right here.
            deletion = output_matrix[i - 1, j] + 1
            insertion = output_matrix[i, j - 1] + 1
            identity = output_matrix[i - 1, j - 1] if ref[i] == donor[j] else np.inf
            substitution = output_matrix[i - 1, j - 1] + 1 if ref[i] != donor[j] else np.inf
            output_matrix[i, j] = min(insertion, deletion, identity, substitution)
    return output_matrix


def identify_changes(ref, donor, offset):
    # logging.warn("identify changes")
    """
    Performs a backtrace-based re-alignment of the donor to the reference and identifies
    SNPS, Insertions, and Deletions.
    Note that if you let either sequence get too large (more than a few thousand), you will
    run into memory issues.
    :param ref: reference sequence (ATCG string)
    :param donor: donor sequence (ATCG string)
    :param offset: The starting location in the genome.
    :return: SNPs, Inserstions, and Deletions
    """
    # print offset
    ref = '${}'.format(ref)
    donor = '${}'.format(donor)
    edit_matrix = edit_distance_matrix(ref=ref, donor=donor)
    current_row = len(ref) - 1
    current_column = len(donor) - 1
    changes = []
    while current_row > 0 or current_column > 0:
        if current_row == 0:
            pvs_row = -np.inf
        else:
            pvs_row = current_row - 1

        if current_column == 0:
            pvs_column = -np.inf
        else:
            pvs_column = current_column - 1

        try:
            insertion_dist = edit_matrix[current_row, pvs_column]
        except IndexError:
            insertion_dist = np.inf

        try:
            deletion_dist = edit_matrix[pvs_row, current_column]
        except IndexError:
            deletion_dist = np.inf

        try:
            if ref[current_row] == donor[current_column]:
                identity_dist = edit_matrix[pvs_row, pvs_column]
            else:
                identity_dist = np.inf

            if ref[current_row] != donor[current_column]:
                substitution_dist = edit_matrix[pvs_row, pvs_column]
            else:
                substitution_dist = np.inf
        except (TypeError, IndexError) as e:
            identity_dist = np.inf
            substitution_dist = np.inf

        min_dist = min(insertion_dist, deletion_dist, identity_dist, substitution_dist)

        ref_index = current_row + offset - 1
        if min_dist == identity_dist:
            current_row = pvs_row
            current_column = pvs_column
        elif min_dist == substitution_dist:
            changes.append(['SNP', ref[current_row], donor[current_column], ref_index])
            current_row = pvs_row
            current_column = pvs_column
        elif min_dist == insertion_dist:
            if len(changes) > 0 and changes[-1][0] == 'INS' and changes[-1][-1] == ref_index + 1:
                changes[-1][1] = donor[current_column] + changes[-1][1]
            else:
                changes.append(['INS', donor[current_column], ref_index + 1])
            current_column = pvs_column
        elif min_dist == deletion_dist:
            if len(changes) > 0 and changes[-1][0] == 'DEL' and changes[-1][-1] == ref_index + 1:
                changes[-1] = ['DEL', ref[current_row] + changes[-1][1], ref_index]
            else:
                changes.append(['DEL', ref[current_row], ref_index])
            current_row = pvs_row
        else:
            raise ValueError
    changes = sorted(changes, key=lambda change: change[-1])
    # print str(changes)
    return changes


def consensus(ref, aligned_reads):
    """
    Identifies a consensus sequence by calling the most commmon base at each location
    in the reference.
    :param ref: reference string
    :param aligned_reads: the list of reads.
    :return: The most common base found at each position in the reads (i.e. the consensus string)
    """
    consensus_string = ''
    padded_reads = [aligned_read + ' ' * (len(ref) - len(aligned_read)) for aligned_read in aligned_reads]
    # The reads are padded with spaces so they are equal in length to the reference
    for i in range(len(ref)):
        base_count = defaultdict(float)
        ref_base = ref[i]
        base_count[ref_base] += 1.1  # If we only have a single read covering a region, we favor the reference.
        read_bases = [padded_read[i] for padded_read in padded_reads if padded_read[i] not in '. ']
        # Spaces and dots (representing the distance between paired ends) do not count as DNA bases
        for base in read_bases:
            base_count[base] += 1
        consensus_base = max(base_count.iterkeys(), key=(lambda key: base_count[key]))
        # The above line chooses (a) key with maximum value in the read_bases dictionary.
        consensus_string += consensus_base


    return consensus_string

if __name__ == "__main__":

    start = time.clock()
    # CPU_start = time.process_time()
    genome_name = 'practice_W_3'
    input_folder = './{}'.format(genome_name)
    chr_name = '{}_chr_1'.format(genome_name)
    reads_fn_end = 'reads_{}.txt'.format(chr_name)

    reads_fn = join(input_folder, reads_fn_end)
    ref_fn_end = 'ref_{}.txt'.format(chr_name)
    ref_fn = join(input_folder, ref_fn_end)
    key_length = 7
    start = time.clock()

    input_fn = join(input_folder, 'aligned_reads_{}.txt'.format(chr_name))
    logging.warn("starting generate_pileup")
    snps, insertions, deletions, inversions = generate_pileup(input_fn)

    output_fn = join(input_folder, 'changes_{}.txt'.format(chr_name))
    zip_fn = join(input_folder, 'changes_{}.zip'.format(chr_name))
    with open(output_fn, 'w') as output_file:
        output_file.write('>' + chr_name + '\n>SNP\n')
        for x in snps:
            output_file.write(','.join([str(u) for u in x[1:]]) + '\n')
        output_file.write('>INS\n')
        for x in insertions:
            output_file.write(','.join([str(u) for u in x[1:]]) + '\n')
        output_file.write('>DEL\n')
        for x in deletions:
            output_file.write(','.join([str(u) for u in x[1:]]) + '\n')
        output_file.write('>INV\n')
        for x in inversions:
            output_file.write(','.join([str(u) for u in x]) + '\n')

    with zipfile.ZipFile(zip_fn, 'w') as myzip:
        myzip.write(output_fn)
    print "Clock Time " + str(time.clock() - start)
    # print "CPU Time " + str(time.process_time()-CPU_start)
